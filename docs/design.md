# 方案设计

---

## 一、需求分析

1. **目标**

   * 将指定的 Markdown 文件或目录中所有外部图片链接下载到本地新目录下的 `images/` 子目录。
   * 在新目录中生成更新后的 Markdown 文件，保留原有目录结构，链接指向本地下载的图片文件。

2. **输入输出**

   * **输入**：

     * 单一 Markdown 文件路径，或
     * 含多个 Markdown 文件的目录（支持递归）。
   * **输出**：

     * 新的 Markdown 文件集合，位于用户指定的输出根目录，保留源结构；
     * 每个输出目录下的 `images/` 子目录，存放该目录下所有下载的图片。

---

## 二、技术选型

* **语言**：Python 3.x
* **解析库**：`markdown-it-py` 或 `mistune` 等专用 Markdown AST 库，用于准确提取和重写图片节点。
* **下载依赖**：`requests`（HTTP 请求与流式下载）
* **文件与路径**：`pathlib`（跨平台路径操作）
* **命令行**：`argparse` 或 `click`（优雅的参数定义与帮助）
* **可选**：

  * `tqdm` —— 下载进度指示
  * `concurrent.futures` —— 并发下载支持

---

## 三、功能模块与流程

1. **命令行接口（CLI）**

   * 参数：

     * `--input` / `-i`：源 Markdown 文件或目录
     * `--output-dir` / `-o`：输出根目录，用于存放新 Markdown 与 `images/` 子目录
     * `--verbose`：可选，开启详细日志
   * 帮助信息：自动生成示例用法、参数说明。

2. **目录扫描与结构映射**

   * 若输入为目录，递归扫描所有 `.md` 文件。
   * 对每个源文件，计算其相对于输入根目录的相对路径，用于在输出根目录中重建相同的子目录结构。

3. **Markdown 解析与图片节点提取**

   * 使用专用 Markdown 解析库（如 `markdown-it-py`）将源文件解析为 AST。
   * 遍历 AST，收集所有图片节点（`![alt](url)`），记录原始 URL 与 `alt` 文本。

4. **本地路径与文件名策略**

   * 对应每个源文件，创建输出子目录及其下的 `images/` 文件夹。
   * 从 URL 中提取原始文件名，确保文件名在该 `images/` 文件夹内唯一（添加序号或哈希后缀）。

5. **图片下载**

   * 针对每个 URL，发起流式 `requests.get` 请求，写入对应输出子目录的 `images/`。
   * 支持超时、重试，并在 `--verbose` 模式下打印成功或失败信息。
   * 可选：并发下载以提升效率。

6. **AST 修改与 Markdown 重新生成**

   * 将 AST 中的每个图片节点的 `src` 字段替换为新的相对路径，如 `images/xxx.png`。
   * 使用解析库的渲染功能，将修改后的 AST 渲染回 Markdown 文本。

7. **写入输出文件**

   * 将渲染后的 Markdown 文本写入输出根目录下对应的子路径中，保持 `.md` 后缀不变。
   * 确保文件权限与原文件一致（可选复制元数据）。

---

## 四、异常处理与日志

* **网络问题**：超时、404、重定向，记录并跳过，继续处理后续图片。
* **文件冲突**：若同名本地文件已存在，通过增加序号或哈希避免覆盖，并记录原 URL 对应关系。
* **解析错误**：Markdown AST 解析或渲染失败时，日志记录文件路径与错误信息，跳过该文件或回退为原始文本复制。
* **日志**：支持 `--verbose` 输出详细下载与替换日志，默认只输出总结信息。

---

## 五、后续扩展

1. **增量更新**：检测已下载图片并跳过，支持只处理新增或修改过的文件。
2. **多资源支持**：扩展至音频、视频等其他外部资源节点。
3. **自定义图片目录名称**：允许用户指定除 `images/` 以外的子目录名。
4. **Dry-run 模式**：仅打印将要执行的下载与替换操作，不写入文件。
5. **配置文件**：支持通过 YAML/JSON 定义下载行为、超时、重试次数等参数。

---

此方案在保留源目录结构的同时，利用专用 Markdown 解析库保证链接提取与重写的准确性，并通过模块化设计提升可维护性与扩展性。下一步即可基于此架构动手实现具体代码。
